//Goal: to measure area of sandbanks of different images

//-Load Images
//-Apply same polygon and clear outside to each image (keeping area of interest only visible, rest black)
//-Color threshold to select sandbanks
//			First test shows best is to select the channels dark colour instead
//			make the selection
//			invert selection
//-Set measurment measure area
//-Measure
//-Show results

//-Area measured can be contrasted among images as all sattelite derived (downloaded with coast snap, should be the same size)



#@ File (label = "Input directory", style = "directory") input
#@ File (label = "Output directory", style = "directory") output
#@ String (label = "File suffix", value = ".jpg") suffix


processFolder(input);

// function to scan folders/subfolders/files to find files with correct suffix
function processFolder(input) {

	//To hide operations
	//setBatchMode(true); 

	
	list = getFileList(input);
	list = Array.sort(list);
	for (i = 0; i < list.length; i++) {
		if(File.isDirectory(input + File.separator + list[i]))
			processFolder(input + File.separator + list[i]);
		if(endsWith(list[i], suffix))
		//processFile(input, output, list[i]);
		processFile(input, list[i]);
	}
	setBatchMode(false); 
}

//function processFile(input, output, file) {
	function processFile(input, file) {
	 open (file);
	 a=getTitle();
print(a);



 //duplicate for white pixel counting part
 //..not necesary in the case of sanbanks since all images are the same size
	// run("Duplicate...", "title=[white pixels]");
	
	
	
//Make polygon with the area of study (sea)
	selectWindow (a);
	
// add here coordinates of the polygon to be extracted/studied. Ej:
	makePolygon(495,680,529,700,553,676,493);
	
	setBackgroundColor(0, 0, 0);
run("Clear Outside");
	
	
//Color thershold to select the channel pixels in the area

		// Color Thresholder 2.1.0/1.53c
		// Autogenerated macro, single images only!

selectWindow (a);
min=newArray(3);
max=newArray(3);
filter=newArray(3);
//a=getTitle();
run("RGB Stack");
run("Convert Stack to Images");
selectWindow("Red");
rename("0");
selectWindow("Green");
rename("1");
selectWindow("Blue");
rename("2");
min[0]=0;
max[0]=50;
filter[0]="pass";
min[1]=0;
max[1]=255;
filter[1]="pass";
min[2]=0;
max[2]=255;
filter[2]="pass";
for (i=0;i<3;i++){
  selectWindow(""+i);
  setThreshold(min[i], max[i]);
  run("Convert to Mask");
  if (filter[i]=="stop") 
  run("Invert");
}
imageCalculator("AND create", "0","1");
imageCalculator("AND create", "Result of 0","2");
for (i=0;i<3;i++){
  selectWindow(""+i);
 close();
}
selectWindow("Result of 0");
close();
selectWindow("Result of Result of 0");
rename(a);


	getHistogram(values, counts, 2);
Array.print(counts);

//Close resulting image (and/or save)
selectWindow(a);
run("Invert");
saveAs("Jpeg",output+a);
close();


// Do the processing here by adding your own code.
	// Leave the print statements until things work, then remove them.
	//print("Processing: " + input + File.separator + file);
	//print("Saving to: " + output);
}
//-----------------------------------------------



///Save excel with the data from the Log
//output = getDirectory("Choose a directory to save the Data");
//selectWindow ("Log");
//saveAs("Text", output + "/Red Pixels" + ".xls");
   // close();


//---------------------------------------

//Instructions to overlap resulting images with previously extracted morphology
//Open image 8bit saved by the previous macro (a) with the filtered morphology


//run("Merge Channels...", "c1=IMAGE 1 c2=IMAGE 2 ETC create");
//run("Close");
//selectWindow("Composite");
//run("Stack to RGB");

